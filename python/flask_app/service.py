import pandas as pd
import importlib.util
import logging
import qwen2_service  # Importa il servizio Qwen2

# Logging configuration
logging.basicConfig(level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s',
                    handlers=[
                        logging.FileHandler("app.log"),
                        logging.StreamHandler()
                    ])


def extract_dataset_details(df: pd.DataFrame) -> dict:
    """
    Extracts information from a Pandas DataFrame.
    
    :param df: Input DataFrame
    :return: Dictionary containing dataset details
    """
    try:
        if not isinstance(df, pd.DataFrame):
            raise TypeError("Input must be a Pandas DataFrame")
        
        missing_data_stats = df.isna().sum()
        duplicate_count = len(df.duplicated())
        categorical_cols = df.select_dtypes(include=['object', 'category']).columns.tolist()
        for col in categorical_cols:
            df[col] = df[col].astype('category').cat.codes
        corr_matrix = df.corr()
        descriptive_statistics = df.describe()

        return {
            "missing_data": missing_data_stats.to_dict(),
            "duplicates": duplicate_count,
            "categorical_columns": categorical_cols,
            #"correlation_matrix": corr_matrix.values.tolist(),
            "descriptive_statistics": descriptive_statistics.to_dict()
        }
    
    except TypeError as e:
        print(f"Error: {e}")
        return None
    
    except Exception as e:
        print(f"An unexpected error occurred: {e}")
        return None

def preprocess_data(file_path: str) -> pd.DataFrame:
    """
    Preprocess the dataframe by generating Python code via Qwen2,
    saving it to a file, and executing it.

    :param df: Original dataframe
    :return: Preprocessed dataframe
    """
    try:
        # Read CSV data (before and after processing)
        df = pd.read_csv(file_path)
        logging.info(f"File loaded successfully")  # Info log

        logging.info("Starting preprocessing of dataframe.")

        # Convert the dataframe to a dictionary for the model
        descriptor = extract_dataset_details(df)
        logging.debug(descriptor)
        logging.debug("Sending dataframe descriptor to Qwen2 service.")

        # Call Qwen2 service to generate Python code
        generated_code = qwen2_service.ask_and_get_response(descriptor)

        if generated_code:
            script_file_path = 'generated_preprocessing.py'
            logging.info(f"Generated preprocessing code received. Saving to {script_file_path}")
            with open(script_file_path, 'w') as script_file:
                script_file.write(generated_code)
                logging.debug("Python code saved successfully.")

            # Import and execute the code
            spec = importlib.util.spec_from_file_location("Preprocess", script_file_path)
            preprocessor_module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(preprocessor_module)

            if hasattr(preprocessor_module, 'preprocess'):
                logging.info("Executing the generated preprocess function.")
                preprocess_data = preprocessor_module.preprocess(df)
                logging.info("Dataframe successfully processed.")
                logging.info(f"Returning the preprocessed dataframe {preprocess_data}.")
                return preprocess_data
            else:
                logging.error("Generated code does not contain a 'main' function.")
        else:
            logging.warning("No code was generated by the Qwen2 service.")
    
    except Exception as e:
        logging.error(f"Error during preprocessing: {e}")

    # In case of error, return the original dataframe
    logging.warning("Returning the original dataframe due to an error or missing preprocessing code.")
    return df